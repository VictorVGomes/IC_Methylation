---
title: "Efeito do fumo na metilação do DNA em células CD8T"
author: "Victor Vinícius Gomes"
format: pdf
editor: visual
---

# Efeito do fumo na metilação do DNA em células CD8T do sangue humano

A instalação dos pacotes a serem utilizados é o primeiro passo para iniciar a análise de dados de metilação. Usando a função do pacote `BiocManager` , `install()` , instala-se os pacotes necessários, e listados nos códigos. Alguns têm tamanho mediano, e podem levar algum tempo até serem instalados.

#### Pacotes exigidos

```{r pacotes exigidos}
knitr::opts_chunk$set(echo = TRUE)
# pacotes usados e que não são do Bioconductor
pacotes = c("fs", 'R.utils', 'limma', 'RColorBrewer', 
            'devtools', 'factoextra', 'limma', 'umap')

# O for loop a seguir instala os pacotes listados acima,
# e, se listados aqui, são usados diretamente no .rmd. 
# Caso exista exitância em instalar algum pacote aqui
# listado, é recomendado procurar um substituto que
# contenha as mesmas funcionalidades que o originalmente
# listado.

for(pacote in pacotes){
  if(!pacote %in% installed.packages())
    install.packages(pacote)
  library(pacote, character.only = TRUE)}


library(minfi)
library(GEOquery)

# abaixo, pacotes possivelmente necessários de se instalar na primeira vez que rodar o código.


# BiocManager::install("IlluminaHumanMethylationEPICanno.ilm10b2.hg19")
# BiocManager::install("IlluminaHumanMethylationEPICmanifest")
# BiocManager::install('minfiData')
# BiocManager::install('sva')
# devtools::install_github("markgene/maxprobes")
# library(IlluminaHumanMethylation450kmanifest)
library(sva)
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
```

Após a instalação dos pacotes, pode-se iniciar a leitura dos dados.

`Como é uma parte que depende de como os dados foram coletados, cada experimento pode fazer essa parte de forma diferente, mas a ideia geral é a mesma, podendo-se generalizar boa parte dos passos aqui descritos, com pequenas alterações para comportar os diferentes experimentos possíveis.`

É possível observar a utilização da função **rm()** ao longo da análise. Vale denotar que o consumo de memória em processamento de dados genéticos é muito grande. Sendo assim, optou-se por remover as variáveis que já haviam sido usadas e não seriam mais acessadas.

#### Início da leitura dos dados

No caso dos dados sobre fumo, os arquivos .IDAT estão disponíveis em dois tipos: experimentos 450k e experimentos EPIC (850k). Como forma de usar ambos, foi decidido que os dados seriam lidos em experimentos separados e, depois, unificados em um único experimento 450k. Assim, a análise será baseada em um experimento 450k, mas é facilmente generalizável para um experimento EPIC.

No `minfi`, pacote usado para processar os dados, podemos listar os tipos de dados que formam uma análise:

1. `rgSet`: formato que armazena as intensidades `red` e `green` da análise. Dependendo de como os dados foram lidos, também contém os dados dos fenótipos. É importante notar que as intensidades armazenadas aqui são apenas das cores `red` e `green`, sendo diferentes das intensidades relativas à metilação e não metilação, adquiridas posteriormente;

2. `MSet`: `methylSet`, é o formato que armazena as intensidades de metilação (e de não metilação) de cada `probe`, para cada amostra. A forma mais simples de obter essa estrutura é usando a função `preprocessRaw()` no `rgSet` (importante notar que não é feita nenhuma normalização nos dados quando a função usada para chegar ao `Mset` é essa);

3. Ao ponto em que tem-se o `MSet`, é possível criar duas novas estruturas: o `GMSet` e o `RSet` 

3.1 O `GMSet`, ou `Genomic Methyl Set`, é quando o `MSet` é mapeado ao genoma usando a função `mapToGenome()`. Isso significa que cada probe do `MSet` terá sua coordenada genômica, além de algumas informações adicionais [ref https://bioconductor.org/help/course-materials/2014/BioC2014/minfi_BioC2014.pdf pag. 8].

3.2 Já o `RSet`, ou `Ratio Set`, refere-se ao `MSet` convertido em uma classe feita para armazenar os valores de Beta e/ou valores M, sendo assim, parte-se das intensidades metiladas e não metiladas e consegue-se os valores de beta e/ou M. É possível obter um `copy number`, a matriz com a soma das intensidades metiladas e não metiladas, para referência futura, dado que esse mapeamento é não-reversível.

4. O `GRSet` - `Genomic Ratio Set` - é a próxima classe a ser gerada: é originada da fusão de 3.1 e 3.2, sendo apenas o `Ratio Set` mapeado ao genoma.


```{r funções auxiliares}

# algumas funções auxiliares

para_png = function(plotAsString, plotName, plotRes=TRUE,
                    dirToSave='/images', ...){
  # aceita argumentos keyWord da função png  (...)
  # plotRes só funciona bem em chunks do .rmd
  # cria diretório "/images/" se esse não existe
  dirr = paste0(getwd(), dirToSave)
  if(!isDirectory(dirr)) # se não existe, cria
    dir.create(dirr)  
  
  file_loc = paste0(dirr, '/', plotName, '.png')
  
  png(file_loc, res = 180, width = 20, height = 10, ...)
  #
  eval(parse(text=plotAsString))
  #
  invisible(dev.off())
  if(plotRes) eval(parse(text=plotAsString))
  
  cat(paste('Salvo em:', file_loc))
}

# 
cria_dir_adiciona_arquivos = function(nomeDir, arquivos, print_results=FALSE){
  wd = paste0(getwd(), "/")
  caminho = paste0(wd, nomeDir)
  
  if(!dir.exists(caminho))
    dir.create(caminho)         # cria o diretório se esse não existe                      
  
  arquivos_ = unlist(strsplit(arquivos, split = "/", fixed = T))[seq(2, length(arquivos) * 2, 2)]
  
  arquivos = arquivos[which(!arquivos_ %in% list.files(caminho))]
  if(length(arquivos)!=0) file.copy(from = paste0(wd, arquivos), to = paste0(caminho,"/", arquivos_))
  
  if (print_results)
    print(list.files(caminho))
}

# Deszipador de arquivos
unzip_files = function(files){
  for(file in files){
    if(file.exists(file) & isGzipped(file) &
       !file.exists(sub(pattern = '.gz$', x = file, replacement = '')))
      gunzip(file, remove=T, )
  }
}
```




```{r organizacao de pastas e arquivos}
untar("GSE147430_RAW.tar", exdir = "GSE147430") # só deve ser feito uma vez

idatFiles = paste0('GSE147430/',list.files('GSE147430/', pattern = "idat.gz$"))
# nomes dos arquivos idat com a adição do caminho até eles do diretório atual

# 91% dos arquivos são 450k (121)
# os outros 9% são EPIC arrays (11)
# total de 132 pacientes (121+11)

files_450k = idatFiles[(file.size(idatFiles) < 5000000)] # file.size mede em bytes
files_EPIC = idatFiles[!(file.size(idatFiles) < 5000000)]


# Os arquivos serão lidos separadamente e, depois, unidos usando a função 
# combineArrays() do pacote minfi, e o produto final será um 450k set, pois
# como a maioria dos dados é 450k, teríamos muitos dados faltantes usando os
# 850k no geral.

# Para a leitura dos arquivos de forma separada, serão criados 2 diretórios:
# o diretório para 450k e o para EPIC arrays

dir_450k = "450kIdatFiles"
dir_EPIC = "EPICIdatFiles"
    
# Criando diretórios para 450k e EPIC
# não é necessário rodar  as funções mais que uma vez

cria_dir_adiciona_arquivos(nomeDir = dir_450k, arquivos = files_450k)
cria_dir_adiciona_arquivos(nomeDir = dir_EPIC, arquivos = files_EPIC)


# checando se o tamanho permanece o mesmo, mas em pastas separadas

tam_separado = (sum(file.size(paste0(dir_EPIC, "/", list.files(dir_EPIC, pattern='.idat.gz$'))))
                + sum(file.size(paste0(dir_450k, "/", list.files(dir_450k, pattern='.idat.gz$'))))) / 1e6

tam_original = sum(file.size(idatFiles)) / 1e6


print(tam_separado == tam_original)

# removendo arquivos do diretório original usados para criar
# os dois diretórios separados.
# unlink vai realmente deletar os arquivos passados a ele,
# portanto, cuidado ao usá-lo.

unlink(idatFiles)

# pronto para ler os arquivos 450k e EPIC em datasets separados

files_450k = list.files(dir_450k, recursive = T, full.names = T, pattern = ".gz")
files_EPIC = list.files(dir_EPIC, recursive = T, full.names = T, pattern = ".gz")

# deszipando arquivos IDAT, removendo arquivos zipados para desocupar espaço
unzip_files(files_450k); unlink(files_450k)
unzip_files(files_EPIC); unlink(files_EPIC)
```




```{r leitura e pre-processamento inicial dos dados}
# lendo experimentos 450k e EPIC separadamente

exp_450k = read.metharray.exp(dir_450k)
exp_EPIC = read.metharray.exp(dir_EPIC, force = T)

sampleNames(exp_450k) = sub('.*?_', '',sampleNames(exp_450k))
sampleNames(exp_EPIC) = sub('.*?_', '',sampleNames(exp_EPIC))

# geoMats e processamento delas

geoMat = getGEO('GSE147430',)
pd.450k = pData(geoMat$`GSE147430-GPL13534_series_matrix.txt.gz`)
pd.EPIC = pData(geoMat$`GSE147430-GPL21145_series_matrix.txt.gz`)
pd.450k$arrayDesign = '450K'
pd.EPIC$arrayDesign = 'EPIC'
rm(geoMat)


pd.All = rbind(pd.450k, pd.EPIC)

# reduzir uso de memória
rm(pd.450k, pd.EPIC)
pdCols = c('title', 'geo_accession', 'smoking_status:ch1', 'arrayDesign')

# algumas correções nos dados dos pacientes

pd.All = pd.All[pdCols]
pd.All$title = sub(']', '', sub('.*\\[','',pd.All$title))
colnames(pd.All)[3] = 'statusFumante'

row.names(pd.All) = pd.All$title


# combinando experimentos 450k e EPIC

rgSet_combined = combineArrays(exp_450k, exp_EPIC,
                               outType="IlluminaHumanMethylation450k")


# liberando memória

rm(exp_450k, exp_EPIC)

# checando se as amostras dos dados de fenótipos batem com 
# os dados do setRG

pd.All = pd.All[sampleNames(rgSet_combined),]

pd.All = as(pd.All, 'DataFrame')


# passando os dados de fenótipo para o rgSet

pData(rgSet_combined) = pd.All
rm(pd.All)
```


### Preprocessamento dos Dados

#### Controle de Qualidade

O controle de qualidade é parte essencial de qualquer análise onde muitas amostras são feitas, e é preciso controlar pelos problemas que podem ser causados pelo ambiente, erros humanos, etc. Ele confere toda a parte anterior à análise diferencial e que procura filtrar os dados de forma a remover *CpGs* com baixa qualidade, ou que não foram de fato detectados. Para esta comparação inicial de detecção, compara-se os *CpGs* de cada indivíduo com *probes* controle, que são compostos apenas de sinal de fundo, ou o ruído do ambiente. Se houver uma diferença significativa - de acordo com um p-valor a ser determinado - então dado *CpG* foi detectado. Quando este p-valor é grande, é um sinal de que aquele *CpG* é composto, em boa parte, por ruído de fundo, configurando um sinal ruim.


```{r detP}
detP = detectionP(rgSet_combined)
falharam <- detP > 0.01

para_png("barplot(colMeans(detP), xlab = 'Amostra', ylab = 'P-valores de detecção', names.arg = '', col=factor(pData(rgSet_combined)$statusFumante), las=2, cex.lab=1.5, cex.sub=1.5); abline(h=0.05, col='red');legend('topleft',legend=levels(factor(pData(rgSet_combined)$statusFumante)), fill=factor(pData(rgSet_combined)$statusFumante), bg='white')", 'Det-P-por-amostra', units = 'in')
```



```{r plotQC}
MSet_raw = preprocessRaw(rgSet_combined) # usado para controle de qualidade, também

# criando o methylSet, podemos fazer outro plot, que separa - ou agrupa - as
# amostras que têm baixa qualidade. Assim, é possível remover todas aquelas que
# não passarem no critério, feito por um limiar relativo ao log 2 da intensidade
# mediana metilada VS não metilada

qc = getQC(MSet_raw)



# é possível automatizar os plots de controle de qualidade usando a função
# qcReport() do Minfi, e analisar os resultados, que são retornados em um pdf
# no diretório atual

# qcReport(rgSet_combined, sampNames = sampleNames(rgSet_combined), sampGroups = pd.All$statusFumante)

para_png("plotQC(qc)", 'qc', units = 'cm')
```





```{r amostras ruins detP}
# remover p-valores maiores que um limiar. Neste caso, foi escolhido o valor
# 0.05. Assim, amostras que tiverem um p-valor maior que 0.05 serão automaticamente
# removidas. Foram detectadas 2 amostras ruins, mostradas a seguir. Essas serão
# removidas pelo nome, para evitar remover pelo índice da coluna, que pode mudar

amostra_ruim_det = colMeans(falharam) > 0.01
quais_amostras_detp = which(amostra_ruim_det==TRUE)
```





```{r density plot raw}
# usando o cutoff disponível na própria função plotQC, encontramos 
# as amostras que são consideradas ruins e as removemos de análises posteriores.
meds <- (qc$mMed + qc$uMed)/2
badSampleCutoff = 10.5 # do próprio minfi
whichBad <- which((meds < badSampleCutoff))

amostrasARemover = union.Vector(quais_amostras_detp, whichBad)
# serão removidas pelo método de preprocessamento, ou antes de preprocessar


# plot de densidade das amostras, raw

para_png("densityPlot(MSet_raw, sampGroups = pData(MSet_raw)$statusFumante, main='Sem Normalização')",'density-plot-raw', units = 'cm')
```




```{r density bean plot raw}
# outros plots estão disponíveis, como do densityBeanPlot:
para_png("densityBeanPlot(MSet_raw, sampGroups = pData(MSet_raw)$statusFumante)", 'density-bean-plot-raw', units = 'in')
```



```{r taxa media de falha por amostra}
# plot interessante para observar se há algum paciente com 
# problemas maiores de detecção dos probes

para_png("plot(as.factor(pData(rgSet_combined)$geo_accession), colMeans(falharam),
     main='Taxa média de falha por amostra', xlab='Amostra',
     ylab='taxa de probes com p-valor de detecção > 0.01', cex.sub=1.7, cex.lab=1.7, cex.main=2)", 'pvalor-falha-amostra', units = 'in')
```



```{r mdsPlot raw}
# índices a serem removidos antes da normalização  
probesRemover = rowMeans(falharam) > 0.05
probesRemover = which(probesRemover==TRUE)

# multi-dimensional scaling plot é uma forma de redução de dimensionalidade
# para a visualização dos dados
# será feito o mds antes e depois do preprocessamento, como forma de 
# analisar as diferenças e identificar padrões nas amostras
# o plot mds pode ser feito tanto no rg_set como nos dados processados
# como o preprocessamento é raw, não há necessidade de fazer o plot nos dados
# gerados por esse preprocessamento.

# analisar outras componentes pode revelar fontes de variação nos dados,
# no entanto, é melhor fazê-lo nos dados normalizados

para_png("mdsPlot(getM(MSet_raw),
        sampNames = rgSet_combined$geo_accession,
        sampGroups=rgSet_combined$statusFumante, )", 'mdsplot-raw', units = 'in')
```



```{r pca eixos 1 e 3 raw}
# O PCA parece ter funcionado bem com as componentes 1 e 4, podendo-se ver algum
# tipo de padrão. No entanto, é apenas um resultado preliminar, já que esses
# dados são enteriores à normalização aplicada, nos dados raw.
set.seed(42)
rgset_samp = t(getMeth(sample(MSet_raw, 4000)))

para_png("print(fviz_pca_ind(prcomp(rgset_samp, center = T, scale.=T), habillage = MSet_raw$statusFumante,
             axes = c(1, 3), addEllipses = T, ellipse.level=0.95))", 'pca-raw_comps1-3', units = 'in')
```


```{r rgset filtros iniciais}
# removendo amostras e probes problemáticos
rgSet_combinedFiltrado = rgSet_combined[-probesRemover, -amostrasARemover]
```


### Normalização

Serão testadas algumas formas diferentes de normalização. As duas candidatas serão a normalização quantílica e Noob. Será feita a demonstração da normalização com e sem as amostras ruins determinadas na parte de controle de qualidade, a fim de mostrar qual a diferença de ter-se apenas boas amostras nos dados analisados. Os plots feitos acima serão refeitos, levando em consideração a correção dos dados, para efeitos de comparação.

<!-- **DROP DE PROBES QUE NÃO FOI FEITO POR CONTROLE DE QUALIDADE PODE SER FEITO DEPOIS DA NORMALIZAÇÃO -->
<!-- DADO QUE NÃO HÁ PROBLEMA DE VALOR NO PROBE, E SIM EFEITO ESPECÍFICO DELE QUE QUER-SE EVITAR* -->
<!-- PARA DROPAR PROBES CROSS-REATIVOS::: -->
<!-- MsetEx_noXloci <- maxprobes::dropXreactiveLoci(MsetEx) -->
<!-- MsetEx_noXloci -->
<!-- Depending on the nature of your samples and your biological question you may also choose to filter out the probes from the X and Y chromosomes or probes that are known to have common SNPs at the CpG site. As the samples in this dataset were all derived from male donors, we will not be removing the sex chromosome probes as part of this analysis, however example code is provided below. A different dataset, which contains both male and female samples, is used to demonstrate a Differential Variability analysis and provides an example of when sex chromosome removal is necessary (Figure 13). -->

<!-- # if your data includes males and females, remove probes on the sex chromosomes -->
<!-- keep <- !(featureNames(mSetSqFlt) %in% ann450k$Name[ann450k$chr %in%  -->
<!--                                                         c("chrX","chrY")]) -->
<!-- table(keep) -->
<!-- mSetSqFlt <- mSetSqFlt[keep,] -->
<!-- There is a function in minfi that provides a simple interface for the removal of probes where common SNPs may affect the CpG. You can either remove all probes affected by SNPs (default), or only those with minor allele frequencies greater than a specified value. -->

<!-- # remove probes with SNPs at CpG site -->
<!-- mSetSqFlt <- dropLociWithSnps(mSetSqFlt) -->
<!-- mSetSqFlt -->
<!-- gset <- dropLociWithSnps(gset, snps=c("SBE","CpG"), maf=0) -->


```{r De rgSet para MSet (normalizacao)}
rm(detP, falharam, MSet_raw, rgset_samp, qc)

# paleta de cores
pal <- brewer.pal(3,"Dark2")

# A normalização será a quantílica
MSetQuantile = preprocessQuantile(object = rgSet_combinedFiltrado,
                          fixOutliers = TRUE, 
                          removeBadSamples = TRUE,
                          badSampleCutoff = 10.5)


# Tentando o preprocessamento Noob, pois foi usada no paper que forneceu os dados
# deve-se remover as amostras ruins na mão

MSetNoob = preprocessNoob(rgSet_combined)
```




```{r mdsPlot quantile e noob, fig.width=20, fig.height=8}
para_png("par(mfrow=c(1,2));mdsPlot(getM(MSetQuantile), sampNames = MSetQuantile$geo_accession, sampGroups = MSetQuantile$statusFumante);mdsPlot(getM(MSetNoob), sampNames = MSetNoob$geo_accession, sampGroups = MSetNoob$statusFumante)",
 'Mset_quant_e_noob', units = 'in')
```





```{r densityPlot quantile}

para_png("densityPlot(getBeta(MSetQuantile), sampGroups = MSetQuantile$statusFumante, main='Normalização Quantílica')", 'Density-plot-quantilica', unit='cm')

```


```{r densityPlot Noob}
para_png("densityPlot(getBeta(MSetNoob), sampGroups = MSetNoob$statusFumante, main='Normalização Noob')", 'Density-plot-noob', unit='cm')

# nota-se que o preprocessamento Noob não foi bem ajustado aos dados, e portanto
# não será utilizado a partir deste ponto, sem a utilização dos demais plots
rm(MSetNoob)
```

Analisando os resultados obtidos nas normalizações determinadas, conclui-se que a normalização quantílica performou melhor. Assim, esta será usada nos passos posteriores, tal como a análise diferencial de metilação. Agora, certa atenção deve ser dada a outros tipos de `probes` que devem ser filtrados antes da análise diferencial. `Probes` relativos ao sexo dos indivíduos (cromossomos X e Y), `cross-hibridized probes`  e `Single Nucleotide Polymorphism` (ou simplesmente `SNP`) devem ser removidos, no geral, como boa prática, quando não são do interesse geral da análise.


<!-- OS SEXOS FORAM PREDITOS NA NORMALIZAÇÃO, ENTÃO DA PRA FAZER ALGUNS PLOTS COM ISSO COMO SEPARADOR -->


```{r filtros adicionais pós-normalização}
ann450k = getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
cpgsManter = !(featureNames(MSetQuantile) %in% ann450k$Name[ann450k$chr %in% c("chrX","chrY")])
rm(ann450k)
# removendo CPGs relacionados ao sexo dos indivíduos.
# antes, nrow=450_292, agora nrow=439_769


MSetQuantile = MSetQuantile[cpgsManter, ]



# removendo SNP (single nucleotide polymorphism)
MSetQuantile <- dropLociWithSnps(MSetQuantile)

# nrow=423_718


# removendo CPGs cross-reativos ref: [https://www.tandfonline.com/doi/full/10.4161/epi.23470]
MSetQuantile <- maxprobes::dropXreactiveLoci(MSetQuantile)

# nrow=391_064
```


```{r mds pós filtragens}
para_png("mdsPlot(getM(MSetQuantile),
        sampNames = MSetQuantile$geo_accession,
        sampGroups=MSetQuantile$statusFumante, )", 'mdsplot-quantile-filtrado', units = 'in')

```


```{r mds usando design do array como separador}
para_png("mdsPlot(getM(MSetQuantile),
        sampNames = MSetQuantile$geo_accession,
        sampGroups=MSetQuantile$arrayDesign, )",
        'mdsplot-quantile-filtrado-arrayDesign',
        units = 'in')
```



```{r pca pós filtragens}
set.seed(42)
mset_samp = t(assay(sample(MSetQuantile, 4000)))

para_png("print(fviz_pca_ind(prcomp(mset_samp, center = T, scale.=T), habillage = MSetQuantile$statusFumante, axes = c(1, 3), addEllipses = T, ellipse.level=0.95))",
         'pca-quantile_filtered_comps1-3',
         units = 'in')
```



```{r pca arrayDesign}
para_png("print(fviz_pca_ind(prcomp(mset_samp, center = T, scale.=T), habillage = MSetQuantile$arrayDesign, axes = c(1, 3), addEllipses = T, ellipse.level=0.95))",
         'pca-quantile_filtered_comps1-3-arrayDesign',
         units = 'in')
```


```{r umap array design}
MSetUmap = umap(mset_samp, preserve.seed = TRUE)
para_png("plot(MSetUmap$layout, col=factor(MSetQuantile$arrayDesign), pch=16, main='UMap Usando o Design do Array como Grupo', xlab='Dimensão 1', ylab='Dimensão 2')",
         'UMap-arrayDesign',
         units='in')
```


```{r umap status fumante}
para_png("plot(MSetUmap$layout, col=factor(MSetQuantile$statusFumante), pch=16, main='UMap Usando o Status de Fumo do Indivíduo como Grupo', xlab='Dimensão 1', ylab='Dimensão 2')",
         'UMap-statusFumante',
         units='in')

```






```{r SVA (surrogate variable analysis)}

mval <- getM(MSetQuantile)
pheno <- pData(MSetQuantile)
mod <- model.matrix(~as.factor(statusFumante), data=pheno)
mod0 <- model.matrix(~1, data=pheno)
sva.results <- sva(mval, mod, mod0)

```




